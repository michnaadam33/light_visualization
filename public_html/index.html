<html> 
    <head> 
        <title>My first Three.js app</title> 
        <style> body { margin: 0; } canvas { width: 100%; height: 100% } </style> 
    </head> 
    <body> 
        <div id="container"><br /><br /><br /><br /><br />Generating world...</div>
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
        <script src="js/three.min.js"></script> 
        <script src="js/controls/FirstPersonControls.js"></script>

        <script src="js/ImprovedNoise.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/libs/stats.min.js"></script>
        <script src="js/connections/connLims.js"></script>
        <script src="js/connections/connMapzen.js"></script>
        <script>
            var poslon = 19972000;
            var poslat = 50066000;
            if (!Detector.webgl) {

                Detector.addGetWebGLMessage();
                document.getElementById('container').innerHTML = "";
            }

            var fogExp2 = true;
            var container, stats;
            var camera, controls, scene, renderer;
            var mesh, mat;
            var worldWidth = 100, worldDepth = 100,
                    worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;
            //data = generateHeight(worldWidth, worldDepth);

            var clock = new THREE.Clock();
            $.when(askLims(),
                    askMapzenRoads(582459, 355316),
                    askMapzenRoads(582460, 355316),
                    askMapzenRoads(582460, 355317),
                    askMapzenRoads(582460, 355318),
                    askMapzenRoads(582460, 355319),
                    askMapzenRoads(582461, 355316),
                    askMapzenRoads(582461, 355317),
                    askMapzenRoads(582461, 355318),
                    askMapzenRoads(582461, 355319),
                    askMapzenRoads(582462, 355316),
                    askMapzenRoads(582462, 355317),
                    askMapzenRoads(582462, 355318),
                    askMapzenRoads(582462, 355319),
                    askMapzenRoads(582463, 355316),
                    askMapzenRoads(582463, 355317),
                    askMapzenRoads(582463, 355318),
                    askMapzenRoads(582463, 355319),
                    askMapzenRoads(582464, 355316),
                    askMapzenRoads(582464, 355317),
                    askMapzenRoads(582464, 355318),
                    askMapzenRoads(582464, 355319),
                    askMapzenRoads(582465, 355316),
                    askMapzenRoads(582465, 355317),
                    askMapzenRoads(582465, 355318),
                    askMapzenRoads(582465, 355319)
                    ).done(function () {
                console.log("Start");
                init();
                animate();
            });
            function init() {

                container = document.getElementById('container');
                camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 20000);
                camera.position.y = 100;
                controls = new THREE.FirstPersonControls(camera);
                controls.movementSpeed = 1000;
                controls.lookSpeed = 0.125;
                controls.lookVertical = true;
                controls.constrainVertical = true;
                controls.verticalMin = 1.1;
                controls.verticalMax = 2.2;
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0xffffff, 0.00015);
                // sides

                var light = new THREE.Color(0xffffff);
                var shadow = new THREE.Color(0x505050);
                var matrix = new THREE.Matrix4();
                var lightPoints = new THREE.BoxGeometry(10, 10, 10);
                var pyGeometryRout = new THREE.PlaneGeometry(100, 100);
                pyGeometryRout.applyMatrix(matrix.makeRotationX(-Math.PI / 2));
                pyGeometryRout.applyMatrix(matrix.makeTranslation(0, 50, 0));
                var pyGeometryPlace = new THREE.PlaneGeometry(100, 100);
                pyGeometryPlace.applyMatrix(matrix.makeRotationX(-Math.PI / 2));
                pyGeometryPlace.applyMatrix(matrix.makeTranslation(0, 50, 0));
                var pyGeometry = new THREE.PlaneGeometry(100, 100);
                //pyGeometry.faces[ 0 ].vertexColors = [light, light, light];
                //pyGeometry.faces[ 1 ].vertexColors = [light, light, light];
                pyGeometry.faceVertexUvs[ 0 ][ 0 ][ 1 ].y = 0.5;
                pyGeometry.faceVertexUvs[ 0 ][ 1 ][ 0 ].y = 0.5;
                pyGeometry.faceVertexUvs[ 0 ][ 1 ][ 1 ].y = 0.5;
                pyGeometry.applyMatrix(matrix.makeRotationX(-Math.PI / 2));
                pyGeometry.applyMatrix(matrix.makeTranslation(0, 50, 0));
                //

                var geometry = new THREE.Geometry();
                var road = new THREE.Geometry();
                var places = new THREE.Geometry();

                var lightsPoints = new THREE.Geometry();
                var dummy = new THREE.Mesh();
                for (var z = 0; z < worldDepth; z++) {

                    for (var x = 0; x < worldWidth; x++) {

                        //var h = getY(x, z);

                        matrix.makeTranslation(
                                x * 100 - worldHalfWidth * 100,
                                10,
                                z * 100 - worldHalfDepth * 100
                                );
                        if (isHereRoute(x, z)) {
                            road.merge(pyGeometryRout, matrix);
                        } else if (isHerePlaces(x, z)) {
                            places.merge(pyGeometryPlace, matrix);
                        }
                        else {
                            geometry.merge(pyGeometry, matrix);
                        }
                        if (isHereLight(x, z)) {
                            lightsPoints.merge(lightPoints, matrix);
                        }


                    }

                }

                var textureRoad = THREE.ImageUtils.loadTexture('textures/minecraft/atlas2.png');
                var textureEarth = THREE.ImageUtils.loadTexture('textures/minecraft/atlas.png');
                textureEarth.magFilter = THREE.NearestFilter;
                textureEarth.minFilter = THREE.LinearMipMapLinearFilter;
                textureRoad.magFilter = THREE.NearestFilter;
                textureRoad.minFilter = THREE.LinearMipMapLinearFilter;
                var mesh = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({map: textureEarth, ambient: 0xbbbbbb, vertexColors: THREE.VertexColors}));
                scene.add(mesh);
                var mesh2 = new THREE.Mesh(road, new THREE.MeshLambertMaterial({map: textureRoad, ambient: 0xbbbbbb, vertexColors: THREE.VertexColors}));
                scene.add(mesh2);
                var material = new THREE.MeshBasicMaterial({color: 0xffffff00});
                var mesh3 = new THREE.Mesh(lightsPoints, material);
                mesh3.position.y = 100;
                scene.add(mesh3);
                
                var material = new THREE.MeshBasicMaterial({color: 0xf1f1f1});
                var meshPlace = new THREE.Mesh(places, material);
                scene.add(meshPlace);
                
                var ambientLight = new THREE.AmbientLight(0xcccccc);
                scene.add(ambientLight);
                var directionalLight = new THREE.DirectionalLight(0xffffff, 2);
                directionalLight.position.set(1, 1, 0.5).normalize();
                scene.add(directionalLight);
                renderer = new THREE.WebGLRenderer();
                renderer.setClearColor(0xffffff);
                renderer.setSize(window.innerWidth, window.innerHeight);
                container.innerHTML = "";
                container.appendChild(renderer.domElement);
                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                container.appendChild(stats.domElement);
                //

                window.addEventListener('resize', onWindowResize, false);
            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                controls.handleResize();
            }

            function loadTexture(path, callback) {

                var image = new Image();
                image.onload = function () {
                    callback();
                };
                image.src = path;
                return image;
            }

            /*function getY(x, z) {
             
             return (data[ x + z * worldWidth ] * 0.2) | 0;
             
             }*/

            //

            function animate() {

                requestAnimationFrame(animate);
                render();
                stats.update();
            }

            function render() {

                controls.update(clock.getDelta());
                renderer.render(scene, camera);
            }
            function isHereLight(x, z) {
                if (lightsCoor.length == 0) {
                    console.log("lights Corr ERRoR");
                }
                for (var i in lightsCoor) {
                    var lon = parseInt(lightsCoor[i].lon / 10);
                    var lat = parseInt(lightsCoor[i].lat / 10);
                    if (lon == x && lat == z) {
                        return true;
                    }
                }
                return false;
            }
            function isHereRoute(x, z) {
                if (routeCoor.length == 0) {
                    console.log("No outeCoor ERRoR");
                }
                //if(z > 10) return false; // test
                for (var i in routeCoor) {

                    var lastPoint = routeCoor[i][0];
                    for (var j = 1; j < routeCoor[i].length; ++j) {

                        var point = routeCoor[i][j];
                        var lon = parseInt(point.lon / 10);
                        var lat = parseInt(point.lat / 10);
                        if (lon == x && lat == z) {
                            return true;
                        }

                        var lonLast = Math.round(lastPoint['lon'] / 10);
                        var latLast = Math.round(lastPoint['lat'] / 10);
                        if ((Math.min(lat, latLast) <= z) && (z <= Math.max(lat, latLast)) &&
                                (Math.min(lon, lonLast) <= x) && (x <= Math.max(lon, lonLast))) {
                            return true;
                        }

                        lastPoint = point;
                    }

                }
                return false;
            }
            
            function isHerePlaces(x, z){
                if (placesCoor.length == 0) {
                    console.log("places Corr ERRoR");
                }
                 for (var i in placesCoor) {
                    var lastPoint = placesCoor[i][0];
                    for (var j = 1; j < placesCoor[i].length; ++j) {

                        var point = placesCoor[i][j];
                        var lon = parseInt(point.lon / 10);
                        var lat = parseInt(point.lat / 10);
                        if (lon == x && lat == z) {
                            return true;
                        }
                        
                        var lonLast = Math.round(lastPoint['lon'] / 10);
                        var latLast = Math.round(lastPoint['lat'] / 10);
                        if ((Math.min(lat, latLast) <= z) && (z <= Math.max(lat, latLast)) &&
                                (Math.min(lon, lonLast) <= x) && (x <= Math.max(lon, lonLast))) {
                            return true;
                        }

                        lastPoint = point;
                    }

                }
                return false;
            }

        </script>

    </body> 
</html>